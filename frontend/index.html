<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Speech Intelligence Platform</title>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #fff;
        }
        .container { max-width: 1400px; margin: 0 auto; padding: 20px; }
        .header {
            text-align: center;
            padding: 30px 0;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            margin-bottom: 30px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
        }
        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            background: linear-gradient(to right, #fff, #a8edea);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        .main-grid { display: grid; grid-template-columns: 2fr 1fr; gap: 20px; margin-bottom: 20px; }
        .card { background: rgba(255, 255, 255, 0.95); border-radius: 20px; padding: 25px; box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1); color: #333; }
        .card h2 { color: #667eea; margin-bottom: 20px; font-size: 1.5em; }
        .recording-section { text-align: center; }
        .mic-button {
            width: 120px;
            height: 120px;
            border-radius: 50%;
            border: none;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            font-size: 48px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 10px 30px rgba(102, 126, 234, 0.4);
            margin: 20px auto;
            display: block;
        }
        .mic-button:hover { transform: scale(1.05); box-shadow: 0 15px 40px rgba(102, 126, 234, 0.6); }
        .mic-button.recording {
            animation: pulse 1.5s infinite;
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
        }
        @keyframes pulse { 0%, 100% { transform: scale(1); } 50% { transform: scale(1.1); } }
        .status { font-size: 1.2em; margin: 15px 0; font-weight: 600; }
        .status.recording { color: #f5576c; }
        .status.idle { color: #667eea; }
        .waveform { height: 100px; background: #f0f0f0; border-radius: 10px; margin: 20px 0; position: relative; overflow: hidden; }
        .waveform-bar {
            position: absolute;
            bottom: 0;
            width: 3px;
            background: linear-gradient(to top, #667eea, #764ba2);
            transition: height 0.1s ease;
        }
        .controls { display: flex; gap: 15px; flex-wrap: wrap; margin: 20px 0; }
        .toggle-group { flex: 1; min-width: 200px; }
        .toggle-label {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 12px;
            background: #f8f9fa;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        .toggle-label:hover { background: #e9ecef; }
        .toggle-input { width: 50px; height: 26px; position: relative; cursor: pointer; }
        .toggle-input input { opacity: 0; width: 0; height: 0; }
        .toggle-slider {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            border-radius: 26px;
            transition: 0.3s;
        }
        .toggle-slider:before {
            position: absolute;
            content: "";
            height: 20px;
            width: 20px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            border-radius: 50%;
            transition: 0.3s;
        }
        .toggle-input input:checked + .toggle-slider { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); }
        .toggle-input input:checked + .toggle-slider:before { transform: translateX(24px); }
        .transcript-box {
            background: #f8f9fa;
            border-radius: 10px;
            padding: 20px;
            min-height: 150px;
            max-height: 300px;
            overflow-y: auto;
            margin: 20px 0;
            font-size: 1.1em;
            line-height: 1.6;
            color: #333;
        }
        .transcript-box.empty { color: #999; font-style: italic; }
        .info-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 15px; margin: 20px 0; }
        .info-card {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px;
            border-radius: 12px;
            text-align: center;
        }
        .info-card .label { font-size: 0.9em; opacity: 0.9; margin-bottom: 8px; }
        .info-card .value { font-size: 1.8em; font-weight: bold; }
        .history-list { max-height: 400px; overflow-y: auto; }
        .history-item {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 10px;
            transition: all 0.3s ease;
        }
        .history-item:hover { background: #e9ecef; transform: translateX(5px); }
        .history-item .time { font-size: 0.85em; color: #666; margin-bottom: 5px; }
        .history-item .text { color: #333; font-weight: 500; }
        .history-item .meta { display: flex; gap: 10px; margin-top: 8px; font-size: 0.9em; }
        .badge { display: inline-block; padding: 4px 12px; border-radius: 20px; font-size: 0.85em; font-weight: 600; }
        .badge-male { background: #3498db; color: white; }
        .badge-female { background: #e91e63; color: white; }
        .badge-command { background: #f39c12; color: white; }
        .badge-dsp { background: #27ae60; color: white; }
        button.action-btn {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            font-size: 1em;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        button.action-btn:hover { transform: translateY(-2px); box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4); }
        .command-detected {
            background: #fff3cd;
            border-left: 4px solid #f39c12;
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
            color: #856404;
        }
        .stats-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px; }
        .processing { color: #667eea; font-style: italic; }
        @media (max-width: 968px) { .main-grid { grid-template-columns: 1fr; } }
        .file-upload-section {
            margin-top: 30px;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 12px;
            border: 2px dashed #667eea;
        }
        .file-upload-section h3 { color: #667eea; margin-bottom: 15px; }
        .file-input-wrapper {
            position: relative;
            display: inline-block;
            width: 100%;
        }
        .file-input-label {
            display: block;
            padding: 15px;
            background: white;
            border: 2px solid #667eea;
            border-radius: 8px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        .file-input-label:hover {
            background: #667eea;
            color: white;
        }
        .file-input-label input[type="file"] {
            position: absolute;
            opacity: 0;
            width: 0;
            height: 0;
        }
        .waveform-comparison {
            margin-top: 30px;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 12px;
        }
        .waveform-comparison h3 { color: #667eea; margin-bottom: 15px; }
        .waveform-canvas-container {
            margin-bottom: 20px;
        }
        .waveform-canvas-container h4 {
            color: #333;
            margin-bottom: 10px;
            font-size: 1.1em;
        }
        .waveform-canvas {
            width: 100%;
            height: 150px;
            background: white;
            border-radius: 8px;
            border: 1px solid #ddd;
        }
        .download-section {
            margin-top: 20px;
            display: flex;
            gap: 15px;
            justify-content: center;
        }
        .download-btn {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            background: linear-gradient(135deg, #27ae60 0%, #2ecc71 100%);
            color: white;
            font-size: 1em;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        .download-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(39, 174, 96, 0.4);
        }
        .download-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }
        .audio-player-section {
            margin-top: 20px;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 12px;
        }
        .audio-player-section h3 {
            color: #667eea;
            margin-bottom: 15px;
        }
        .audio-player-container {
            margin-bottom: 15px;
        }
        .audio-player-container h4 {
            color: #333;
            margin-bottom: 10px;
            font-size: 1em;
        }
        .audio-player-container audio {
            width: 100%;
            margin-top: 5px;
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        const API_URL = 'http://localhost:8000';

        function App() {
            const [isRecording, setIsRecording] = useState(false);
            const [transcript, setTranscript] = useState('');
            const [gender, setGender] = useState('');
            const [command, setCommand] = useState(null);
            const [enableDSP, setEnableDSP] = useState(true);
            const [predictGender, setPredictGender] = useState(true);
            const [history, setHistory] = useState([]);
            const [stats, setStats] = useState(null);
            const [waveformBars, setWaveformBars] = useState(Array(50).fill(0));
            const [processing, setProcessing] = useState(false);
            const [uploadedFile, setUploadedFile] = useState(null);
            const [waveformData, setWaveformData] = useState(null);
            const [currentRecordId, setCurrentRecordId] = useState(null);
            const [originalAudioUrl, setOriginalAudioUrl] = useState(null);
            const [processedAudioUrl, setProcessedAudioUrl] = useState(null);

            const mediaRecorderRef = useRef(null);
            const audioChunksRef = useRef([]);
            const audioContextRef = useRef(null);
            const analyserRef = useRef(null);
            const animationRef = useRef(null);
            const originalCanvasRef = useRef(null);
            const processedCanvasRef = useRef(null);

            useEffect(() => {
                fetchHistory();
                fetchStats();
            }, []);

            useEffect(() => {
                if (isRecording) {
                    startVisualization();
                } else {
                    stopVisualization();
                }
            }, [isRecording]);

            const startVisualization = () => {
                if (!analyserRef.current) return;

                const analyze = () => {
                    const dataArray = new Uint8Array(analyserRef.current.frequencyBinCount);
                    analyserRef.current.getByteFrequencyData(dataArray);

                    const bars = [];
                    const barCount = 50;
                    const step = Math.floor(dataArray.length / barCount);
                    for (let i = 0; i < barCount; i++) {
                        const value = dataArray[i * step] / 255;
                        bars.push(value);
                    }
                    setWaveformBars(bars);

                    animationRef.current = requestAnimationFrame(analyze);
                };

                analyze();
            };

            const stopVisualization = () => {
                if (animationRef.current) {
                    cancelAnimationFrame(animationRef.current);
                }
                setWaveformBars(Array(50).fill(0));
            };

            const startRecording = async () => {
                try {
                    console.log('üé§ Starting recording...');
                    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });

                    audioContextRef.current = new (window.AudioContext || window.webkitAudioContext)();
                    analyserRef.current = audioContextRef.current.createAnalyser();
                    const source = audioContextRef.current.createMediaStreamSource(stream);
                    source.connect(analyserRef.current);
                    analyserRef.current.fftSize = 256;

                    mediaRecorderRef.current = new MediaRecorder(stream);
                    audioChunksRef.current = [];

                    mediaRecorderRef.current.ondataavailable = (event) => {
                        console.log('üì¶ Audio chunk received:', event.data.size, 'bytes');
                        audioChunksRef.current.push(event.data);
                    };

                    mediaRecorderRef.current.onstop = async () => {
                        console.log('‚èπÔ∏è Recording stopped. Total chunks:', audioChunksRef.current.length);
                        const audioBlob = new Blob(audioChunksRef.current, { type: 'audio/wav' });
                        console.log('üìä Audio blob size:', audioBlob.size, 'bytes');
                        await processAudio(audioBlob);
                        stream.getTracks().forEach(track => track.stop());
                    };

                    // Record in 100ms chunks
                    mediaRecorderRef.current.start(100);
                    setIsRecording(true);
                    setTranscript('');
                    setGender('');
                    setCommand(null);
                    console.log('‚úÖ Recording started!');
                } catch (error) {
                    console.error('‚ùå Error accessing microphone:', error);
                    alert('Unable to access microphone. Please check permissions.\n\nError: ' + error.message);
                }
            };

            const stopRecording = () => {
                if (mediaRecorderRef.current && isRecording) {
                    mediaRecorderRef.current.stop();
                    setIsRecording(false);
                    if (audioContextRef.current) {
                        audioContextRef.current.close();
                    }
                }
            };

            const processAudio = async (audioBlob) => {
                setProcessing(true);
                setTranscript('‚è≥ Processing audio...');

                try {
                    console.log('üîÑ Processing audio blob...');

                    if (audioBlob.size === 0) {
                        throw new Error('Audio blob is empty! Try recording for at least 3 seconds.');
                    }

                    const arrayBuffer = await audioBlob.arrayBuffer();
                    console.log('üì¶ Array buffer size:', arrayBuffer.byteLength);

                    const audioContext = new AudioContext({ sampleRate: 16000 });
                    const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);

                    const audioData = audioBuffer.getChannelData(0);
                    const duration = audioData.length / 16000;
                    console.log('‚è±Ô∏è Audio duration:', duration.toFixed(2), 'seconds');
                    console.log('üìä Audio samples:', audioData.length);

                    if (duration < 0.5) {
                        throw new Error('Recording too short! Please record for at least 3 seconds.');
                    }

                    // Convert Float32Array to base64 properly
                    // Float32Array is 4 bytes per sample
                    const float32Buffer = new Float32Array(audioData);
                    const uint8Buffer = new Uint8Array(float32Buffer.buffer);

                    console.log('üíæ Float32 buffer:', float32Buffer.length, 'samples');
                    console.log('üíæ Uint8 buffer:', uint8Buffer.length, 'bytes');

                    // Convert to base64 - use proper method
                    let binary = '';
                    const chunkSize = 8192;  // Smaller chunks
                    for (let i = 0; i < uint8Buffer.length; i += chunkSize) {
                        const chunk = uint8Buffer.subarray(i, Math.min(i + chunkSize, uint8Buffer.length));
                        binary += String.fromCharCode.apply(null, Array.from(chunk));
                    }
                    const base64Audio = btoa(binary);

                    console.log('üì§ Sending', audioData.length, 'samples (', base64Audio.length, 'base64 chars) to backend...');

                    const response = await fetch(`${API_URL}/api/transcribe`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            audio_base64: base64Audio,
                            enable_dsp: enableDSP,
                            predict_gender_flag: predictGender
                        })
                    });

                    if (!response.ok) {
                        throw new Error(`Server error: ${response.status} ${response.statusText}`);
                    }

                    const result = await response.json();
                    console.log('‚úÖ Server response:', result);

                    if (result.success) {
                        if (!result.transcript || result.transcript.trim() === '') {
                            setTranscript('‚ö†Ô∏è No speech detected. Please speak louder or closer to the microphone.');
                        } else {
                            setTranscript(result.transcript);
                        }
                        setGender(result.gender);
                        setCommand(result.command.detected ? result.command : null);
                        setCurrentRecordId(result.record_id);
                        console.log('‚úÖ Recording saved with ID:', result.record_id);

                        // Store DSP and gender stats for display
                        setStats({
                            dsp_stats: result.dsp_stats,
                            gender_features: result.gender_features,
                            duration: result.duration,
                            method: result.whisper_method
                        });

                        // Handle waveform data
                        if (result.waveform) {
                            setWaveformData(result.waveform);

                            // Decode base64 to Float32Array
                            const originalBytes = Uint8Array.from(atob(result.waveform.original), c => c.charCodeAt(0));
                            const processedBytes = Uint8Array.from(atob(result.waveform.processed), c => c.charCodeAt(0));

                            const originalAudio = new Float32Array(originalBytes.buffer);
                            const processedAudio = new Float32Array(processedBytes.buffer);

                            // Create audio blobs for playback
                            const originalBlob = createAudioBlob(originalAudio, 16000);
                            const processedBlob = createAudioBlob(processedAudio, 16000);

                            // Create object URLs for audio players
                            const origUrl = URL.createObjectURL(originalBlob);
                            const procUrl = URL.createObjectURL(processedBlob);

                            // Cleanup old URLs
                            if (originalAudioUrl) URL.revokeObjectURL(originalAudioUrl);
                            if (processedAudioUrl) URL.revokeObjectURL(processedAudioUrl);

                            setOriginalAudioUrl(origUrl);
                            setProcessedAudioUrl(procUrl);

                            // Draw waveforms
                            setTimeout(() => {
                                if (originalCanvasRef.current) {
                                    drawWaveform(originalCanvasRef.current, originalAudio, '#e74c3c');
                                }
                                if (processedCanvasRef.current) {
                                    drawWaveform(processedCanvasRef.current, processedAudio, '#27ae60');
                                }
                            }, 100);
                        }

                        fetchHistory();
                    } else {
                        setTranscript('‚ùå Error: Could not process audio');
                    }
                } catch (error) {
                    console.error('‚ùå Error processing audio:', error);
                    setTranscript('‚ùå Error: ' + error.message);
                } finally {
                    setProcessing(false);
                }
            };

            const fetchHistory = async () => {
                try {
                    const response = await fetch(`${API_URL}/api/history?limit=20`);
                    const data = await response.json();
                    if (data.success) {
                        setHistory(data.records.reverse());
                    }
                } catch (error) {
                    console.error('Error fetching history:', error);
                }
            };

            const fetchStats = async () => {
                try {
                    const response = await fetch(`${API_URL}/api/stats`);
                    const data = await response.json();
                    if (data.success) {
                        // Don't overwrite local stats with server stats
                        // Server stats are different from recording stats
                        console.log('Server stats:', data.stats);
                    }
                } catch (error) {
                    console.error('Error fetching stats:', error);
                }
            };

            const clearHistory = async () => {
                if (confirm('Clear all history?')) {
                    try {
                        await fetch(`${API_URL}/api/history`, { method: 'DELETE' });
                        setHistory([]);
                        fetchStats();
                    } catch (error) {
                        console.error('Error clearing history:', error);
                    }
                }
            };

            const createAudioBlob = (float32Array, sampleRate = 16000) => {
                // Convert Float32Array to WAV blob for playback
                const numChannels = 1;
                const buffer = new ArrayBuffer(44 + float32Array.length * 2);
                const view = new DataView(buffer);

                // WAV header
                const writeString = (offset, string) => {
                    for (let i = 0; i < string.length; i++) {
                        view.setUint8(offset + i, string.charCodeAt(i));
                    }
                };

                writeString(0, 'RIFF');
                view.setUint32(4, 36 + float32Array.length * 2, true);
                writeString(8, 'WAVE');
                writeString(12, 'fmt ');
                view.setUint32(16, 16, true); // fmt chunk size
                view.setUint16(20, 1, true); // PCM format
                view.setUint16(22, numChannels, true);
                view.setUint32(24, sampleRate, true);
                view.setUint32(28, sampleRate * numChannels * 2, true);
                view.setUint16(32, numChannels * 2, true);
                view.setUint16(34, 16, true); // bits per sample
                writeString(36, 'data');
                view.setUint32(40, float32Array.length * 2, true);

                // Convert float32 to int16
                let offset = 44;
                for (let i = 0; i < float32Array.length; i++) {
                    const sample = Math.max(-1, Math.min(1, float32Array[i]));
                    view.setInt16(offset, sample * 0x7FFF, true);
                    offset += 2;
                }

                return new Blob([buffer], { type: 'audio/wav' });
            };

            const drawWaveform = (canvas, audioData, color = '#667eea') => {
                if (!canvas || !audioData || audioData.length === 0) return;

                const ctx = canvas.getContext('2d');
                const width = canvas.width;
                const height = canvas.height;

                // Clear canvas
                ctx.fillStyle = 'white';
                ctx.fillRect(0, 0, width, height);

                // Draw waveform
                ctx.strokeStyle = color;
                ctx.lineWidth = 2;
                ctx.beginPath();

                const step = Math.ceil(audioData.length / width);
                const amp = height / 2;

                for (let i = 0; i < width; i++) {
                    const min = audioData.slice(i * step, (i + 1) * step).reduce((a, b) => Math.min(a, b), 1);
                    const max = audioData.slice(i * step, (i + 1) * step).reduce((a, b) => Math.max(a, b), -1);

                    if (i === 0) {
                        ctx.moveTo(i, (1 + min) * amp);
                    }
                    ctx.lineTo(i, (1 + min) * amp);
                    ctx.lineTo(i, (1 + max) * amp);
                }

                ctx.stroke();

                // Draw center line
                ctx.strokeStyle = '#ddd';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(0, height / 2);
                ctx.lineTo(width, height / 2);
                ctx.stroke();
            };

            const handleFileUpload = async (event) => {
                const file = event.target.files[0];
                if (!file) return;

                if (!file.name.match(/\.(wav|mp3)$/i)) {
                    alert('Please upload a .wav or .mp3 file');
                    return;
                }

                setUploadedFile(file);
                setProcessing(true);
                console.log('üìÅ Uploading file:', file.name);

                try {
                    const formData = new FormData();
                    formData.append('file', file);
                    formData.append('enable_dsp', enableDSP);
                    formData.append('predict_gender', predictGender);

                    const response = await fetch(`${API_URL}/api/upload-audio`, {
                        method: 'POST',
                        body: formData
                    });

                    if (!response.ok) {
                        throw new Error(`Server error: ${response.status}`);
                    }

                    const data = await response.json();
                    console.log('‚úÖ File processed:', data);

                    // Update UI
                    setTranscript(data.transcript);
                    setGender(data.gender);
                    setCommand(data.command);
                    setCurrentRecordId(data.record_id);
                    console.log('‚úÖ File uploaded with ID:', data.record_id);

                    // Store waveform data
                    if (data.waveform) {
                        setWaveformData(data.waveform);

                        // Decode base64 to Float32Array
                        const originalBytes = Uint8Array.from(atob(data.waveform.original), c => c.charCodeAt(0));
                        const processedBytes = Uint8Array.from(atob(data.waveform.processed), c => c.charCodeAt(0));

                        const originalAudio = new Float32Array(originalBytes.buffer);
                        const processedAudio = new Float32Array(processedBytes.buffer);

                        // Create audio blobs for playback
                        const originalBlob = createAudioBlob(originalAudio, 16000);
                        const processedBlob = createAudioBlob(processedAudio, 16000);

                        // Create object URLs for audio players
                        const origUrl = URL.createObjectURL(originalBlob);
                        const procUrl = URL.createObjectURL(processedBlob);

                        // Cleanup old URLs
                        if (originalAudioUrl) URL.revokeObjectURL(originalAudioUrl);
                        if (processedAudioUrl) URL.revokeObjectURL(processedAudioUrl);

                        setOriginalAudioUrl(origUrl);
                        setProcessedAudioUrl(procUrl);

                        // Draw waveforms
                        setTimeout(() => {
                            if (originalCanvasRef.current) {
                                drawWaveform(originalCanvasRef.current, originalAudio, '#e74c3c');
                            }
                            if (processedCanvasRef.current) {
                                drawWaveform(processedCanvasRef.current, processedAudio, '#27ae60');
                            }
                        }, 100);
                    }

                    // Update stats
                    setStats({
                        duration: data.duration,
                        method: data.whisper_method,
                        dsp_stats: data.dsp_stats,
                        gender_features: data.gender_features
                    });

                    // Update history
                    fetchHistory();

                } catch (error) {
                    console.error('‚ùå Upload error:', error);
                    alert('Failed to process file: ' + error.message);
                } finally {
                    setProcessing(false);
                }
            };

            const downloadAudio = async (format) => {
                if (!currentRecordId) {
                    alert('No audio to download. Please record or upload audio first.');
                    return;
                }

                console.log(`üì• Downloading ${format} with record_id:`, currentRecordId);

                try {
                    const response = await fetch(`${API_URL}/api/download-audio/${currentRecordId}?format=${format}`);

                    if (!response.ok) {
                        throw new Error(`Download failed: ${response.status}`);
                    }

                    const blob = await response.blob();
                    const url = window.URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `processed_audio_${currentRecordId}.${format}`;
                    document.body.appendChild(a);
                    a.click();
                    window.URL.revokeObjectURL(url);
                    document.body.removeChild(a);

                    console.log(`‚úÖ Downloaded as ${format}`);
                } catch (error) {
                    console.error('‚ùå Download error:', error);
                    alert('Failed to download: ' + error.message);
                }
            };

            return (
                <div className="container">
                    <div className="header">
                        <h1>üéôÔ∏è AI Speech Intelligence Platform</h1>
                        <p>Real-Time DSP + Whisper + ML Voice Processing</p>
                    </div>

                    <div className="main-grid">
                        <div className="card">
                            <h2>üé§ Recording Studio</h2>
                            
                            <div className="recording-section">
                                <button 
                                    className={`mic-button ${isRecording ? 'recording' : ''}`}
                                    onClick={isRecording ? stopRecording : startRecording}
                                    disabled={processing}
                                >
                                    {isRecording ? '‚èπÔ∏è' : 'üéôÔ∏è'}
                                </button>
                                
                                <div className={`status ${isRecording ? 'recording' : 'idle'}`}>
                                    {processing ? '‚è≥ Processing...' : isRecording ? 'üî¥ Recording...' : '‚ö™ Ready to Record'}
                                </div>

                                <div className="waveform">
                                    {waveformBars.map((height, i) => (
                                        <div 
                                            key={i}
                                            className="waveform-bar"
                                            style={{
                                                left: `${i * 2}%`,
                                                height: `${height * 100}%`
                                            }}
                                        />
                                    ))}
                                </div>
                            </div>

                            <div className="controls">
                                <div className="toggle-group">
                                    <label className="toggle-label">
                                        <span className="toggle-input">
                                            <input 
                                                type="checkbox" 
                                                checked={enableDSP}
                                                onChange={(e) => setEnableDSP(e.target.checked)}
                                            />
                                            <span className="toggle-slider"></span>
                                        </span>
                                        <span>DSP Noise Reduction</span>
                                    </label>
                                </div>
                                <div className="toggle-group">
                                    <label className="toggle-label">
                                        <span className="toggle-input">
                                            <input 
                                                type="checkbox" 
                                                checked={predictGender}
                                                onChange={(e) => setPredictGender(e.target.checked)}
                                            />
                                            <span className="toggle-slider"></span>
                                        </span>
                                        <span>Gender Prediction</span>
                                    </label>
                                </div>
                            </div>

                            <h3 style={{marginTop: 30, marginBottom: 15, color: '#667eea'}}>üìù Transcript</h3>
                            <div className={`transcript-box ${!transcript ? 'empty' : processing ? 'processing' : ''}`}>
                                {transcript || 'Click the microphone and speak for 3-5 seconds...'}
                            </div>

                            {command && command.detected && (
                                <div className="command-detected">
                                    <strong>üéØ Command Detected:</strong> {command.text}
                                </div>
                            )}

                            <div className="info-grid">
                                {gender && gender !== 'unknown' && (
                                    <div className="info-card">
                                        <div className="label">Gender</div>
                                        <div className="value">{gender === 'male' ? 'üë® Male' : 'üë© Female'}</div>
                                    </div>
                                )}
                            </div>

                            {stats && stats.dsp_stats && (
                                <div style={{marginTop: 20}}>
                                    <h3 style={{color: '#667eea', marginBottom: 10}}>üîä DSP Noise Reduction Analysis</h3>
                                    <div className="info-grid">
                                        <div className="info-card">
                                            <div className="label">DSP Status</div>
                                            <div className="value">{stats.dsp_stats.applied ? '‚úÖ Active' : '‚ùå Off'}</div>
                                        </div>
                                        <div className="info-card">
                                            <div className="label">Voice Activity</div>
                                            <div className="value">{(stats.dsp_stats.voice_ratio * 100).toFixed(0)}%</div>
                                        </div>
                                        <div className="info-card">
                                            <div className="label">Noise Reduction</div>
                                            <div className="value">{stats.dsp_stats.noise_reduction_db?.toFixed(1) || 0} dB</div>
                                        </div>
                                        <div className="info-card">
                                            <div className="label">Noise Level</div>
                                            <div className="value">{(stats.dsp_stats.noise_level * 1000).toFixed(2)}</div>
                                        </div>
                                        <div className="info-card">
                                            <div className="label">PSNR</div>
                                            <div className="value">{stats.dsp_stats.psnr?.toFixed(1) || 0} dB</div>
                                        </div>
                                        <div className="info-card">
                                            <div className="label">SNR</div>
                                            <div className="value">{stats.dsp_stats.snr?.toFixed(1) || 0} dB</div>
                                        </div>
                                        {stats.gender_features && (
                                            <>
                                                <div className="info-card">
                                                    <div className="label">Pitch (F0)</div>
                                                    <div className="value">{Math.round(stats.gender_features.pitch)} Hz</div>
                                                </div>
                                                <div className="info-card">
                                                    <div className="label">Formant F1</div>
                                                    <div className="value">{Math.round(stats.gender_features.formant_f1)} Hz</div>
                                                </div>
                                                <div className="info-card">
                                                    <div className="label">Spectral Centroid</div>
                                                    <div className="value">{Math.round(stats.gender_features.spectral_centroid)} Hz</div>
                                                </div>
                                            </>
                                        )}
                                    </div>
                                </div>
                            )}

                            {/* File Upload Section */}
                            <div className="file-upload-section">
                                <h3>üìÅ Upload Audio File</h3>
                                <div className="file-input-wrapper">
                                    <label className="file-input-label">
                                        <input
                                            type="file"
                                            accept=".wav,.mp3"
                                            onChange={handleFileUpload}
                                            disabled={processing}
                                        />
                                        üì§ {uploadedFile ? uploadedFile.name : 'Choose WAV or MP3 file'}
                                    </label>
                                </div>
                                <p style={{marginTop: 10, fontSize: '0.9em', color: '#666', textAlign: 'center'}}>
                                    Upload .wav or .mp3 audio files for processing
                                </p>
                            </div>

                            {/* Waveform Comparison */}
                            {waveformData && (
                                <div className="waveform-comparison">
                                    <h3>üìä Waveform Comparison: Before & After DSP</h3>

                                    <div className="waveform-canvas-container">
                                        <h4>üî¥ Original Audio (With Noise)</h4>
                                        <canvas
                                            ref={originalCanvasRef}
                                            className="waveform-canvas"
                                            width={800}
                                            height={150}
                                        />
                                    </div>

                                    <div className="waveform-canvas-container">
                                        <h4>üü¢ Processed Audio (Noise Reduced)</h4>
                                        <canvas
                                            ref={processedCanvasRef}
                                            className="waveform-canvas"
                                            width={800}
                                            height={150}
                                        />
                                    </div>

                                    {/* Audio Players */}
                                    {originalAudioUrl && processedAudioUrl && (
                                        <div className="audio-player-section">
                                            <h3>üéß Listen & Compare Audio Quality</h3>

                                            <div className="audio-player-container">
                                                <h4>üî¥ Original Audio (With Noise)</h4>
                                                <audio controls src={originalAudioUrl} />
                                            </div>

                                            <div className="audio-player-container">
                                                <h4>üü¢ Processed Audio (Noise Reduced)</h4>
                                                <audio controls src={processedAudioUrl} />
                                            </div>

                                            <p style={{marginTop: 15, fontSize: '0.9em', color: '#666', textAlign: 'center'}}>
                                                üéØ Play both audio files to hear the difference in noise reduction quality!
                                            </p>
                                        </div>
                                    )}

                                    <div className="download-section">
                                        <button
                                            className="download-btn"
                                            onClick={() => downloadAudio('wav')}
                                            disabled={!currentRecordId || processing}
                                        >
                                            üíæ Download WAV
                                        </button>
                                        <button
                                            className="download-btn"
                                            onClick={() => downloadAudio('mp3')}
                                            disabled={!currentRecordId || processing}
                                        >
                                            üíæ Download MP3
                                        </button>
                                    </div>
                                </div>
                            )}
                        </div>

                        <div>
                            <div className="card" style={{marginBottom: 20}}>
                                <h2>üìä Last Recording</h2>
                                {stats ? (
                                    <div className="stats-grid">
                                        <div className="info-card">
                                            <div className="label">Duration</div>
                                            <div className="value">{stats.duration?.toFixed(1) || 0}s</div>
                                        </div>
                                        <div className="info-card">
                                            <div className="label">Method</div>
                                            <div className="value">{stats.method || 'N/A'}</div>
                                        </div>
                                        {stats.dsp_stats && (
                                            <>
                                                <div className="info-card">
                                                    <div className="label">DSP</div>
                                                    <div className="value">{stats.dsp_stats.applied ? '‚úÖ' : '‚ùå'}</div>
                                                </div>
                                                <div className="info-card">
                                                    <div className="label">Voice</div>
                                                    <div className="value">{(stats.dsp_stats.voice_ratio * 100).toFixed(0)}%</div>
                                                </div>
                                            </>
                                        )}
                                    </div>
                                ) : (
                                    <p style={{color: '#999', textAlign: 'center', padding: 20}}>
                                        No recording yet
                                    </p>
                                )}
                            </div>

                            <div className="card">
                                <h2>üìú History</h2>
                                <button 
                                    className="action-btn" 
                                    onClick={clearHistory}
                                    style={{marginBottom: 15, width: '100%'}}
                                >
                                    Clear History
                                </button>
                                <div className="history-list">
                                    {history.length === 0 ? (
                                        <p style={{color: '#999', textAlign: 'center', padding: 20}}>
                                            No recordings yet
                                        </p>
                                    ) : (
                                        history.map((item) => (
                                            <div key={item.id} className="history-item">
                                                <div className="time">
                                                    {new Date(item.timestamp).toLocaleTimeString()}
                                                </div>
                                                <div className="text">{item.transcript}</div>
                                                <div className="meta">
                                                    {item.gender !== 'unknown' && (
                                                        <span className={`badge badge-${item.gender}`}>
                                                            {item.gender}
                                                        </span>
                                                    )}
                                                    {item.dsp_enabled && (
                                                        <span className="badge badge-dsp">DSP</span>
                                                    )}
                                                    {item.command && item.command.detected && (
                                                        <span className="badge badge-command">CMD</span>
                                                    )}
                                                </div>
                                            </div>
                                        ))
                                    )}
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            );
        }

        ReactDOM.render(<App />, document.getElementById('root'));
    </script>
</body>
</html>